Tasks - REACT NATIVE - completo
Começamos criando banco de dados e api

1.Usaremos o postgree entao baixamos ele, na instalação criamos uma senha que posteriormente nos entraremos no perfil postgres com o comando *psql -U postgres

A partir disso ja podemos dar *\l e ver nossos dbs

Depois entao criamos nosso database com *CREATE DATABASE tasks, e para conectar nele usaremos * \c tasks e assim podendo acessar as tabelas com *\dt

************************************************************

2.Depois partimos para o knex que instalaremos com o npm, no curso a gente instala com *npm install -g knex e dentro nos executamos o comando *knex init pra criar o nosso arquivo knexfile.js onde vai ter as configurações para conectarmos nossa parte do js com o banco de dados,nessas configurações terão informações como o client,que vai mostrar que o banco de dados é em postgresql,configuração de conexao,onde é passado o nome do db,o usuario e senha, pool que vai ser a quantidade minima e maxima de usuarios conectados, e o migrations que vai ter a tabela knex_migrations que tera o "registro" dos migrations que darei no meu db

3.A partir daqui ja podemos criar nossas tabelas usando migrations do knex, com o comando *knex migrate: make create_table_users onde no meu projeto vai ser criado um arquivo dentro da pasta migrations e nesse arquivo há dois a exportação de duas funções
-uma up em que nos fazemos a criação de uma tabela
-e o down seria o contrario do up, ou seja, um drop nessa tabela

4.depois de passar os codigos corretos para up e down,nos podemos salvar isso para o postgre com o comando *knex migrate:latest que atualiza qualquer migration pendente e nos podemos usar *knex migrate:rollback para desfazer a ultima latest

5.enfim,assim fazemos a nossa tabela com os campos que definimos na função up

************************************************************

1.Agora com essas coisas ja configuradas nos podemos criar um arquivo config onde tera por exemplo inicialmente o nosso knex configurado para dar migrate:latest(dai nos sempre garantimos que as migrations vao estar atualizadas alem de ter a instancia do knex,tipo amarrado) e isso ficara no db.js dentro da pasta config. Nos estamos fazendo exportações nesse projeto no modelo commonJS

2.nos usaremos o consign, O Consign é uma biblioteca que ajuda a carregar e organizar automaticamente os módulos em seu projeto. Ao ser utilizado no arquivo principal da API, ele permite que você inclua e carregue os módulos, como rotas e controladores, de maneira automática e na ordem desejada. Isso facilita a gestão do código, evitando a necessidade de fazer require manual em cada módulo.Usaremos ele no index.js

3.No nosso index.js nos vamos criar uma instancia express, algo como:
const express = require('express')
const app = express()

e vamos pegar essa instancia e criar uma nova propriedade para ela,que vai ser db recebendo nossa instancia do knex configurada,ou seja
 app.db 

4.Em config colocaremos tbm um middlewares.js que vai ser os nossos middlewares globais e exportaremos(tbm no modelo commonJS como mencionado anteriormente), em que nos vamos precisar do bodyParser e cors, nos vamos exportar uma função que nos deduzeriamos que nos receberemos a instancia express, e essa instancia vai usar esse bodyParser.json e o cors. Em que o bodyParser serve para fazer o parse do corpo das requisições JSON e o cors permite requisições de qualquer origem(por exemplo um navegador qualquer ou um app em React Native)

5.Depois criamos a pasta api com o arquivo user.js que dai começaremos a fazer algo de api rest mesmo.Que será a parte do signup do usuario na aplicação

Nesse user.js nos importaremos(com require,commonJS) o bcrypt, e exportaremos ali uma função que vamos receber a instancia do express pra dar um insert dos dados com o app.db que definimos no index.js, que receberemos

nos primeiro fazemos dentro dessa função uma função para gerar um hash baseado na nossa senha.
E depois o nosso controller(processa a requisição e interage com o banco de dados) que vai pegar a requisição que vai vim,name,email e passamos a hash gerada a partir do password e dar o insert em users com um then pra caso de sucesso e um catch caso aconteça um erro e exportamos essa função save de modo q ela possa ser usada fora desse modulo

6.Assim com essa função ja feita nos colocaremos ela no routes.js em uma instancia do express que faz post na rota /signup usando esse controller,ficando algo como:
module.exports = app => {
    app.post('/signup', app.api.user.save)

7.Depois nos criamos um .env que exporta o valor de authSecret: '#$fhfjh&.sjhg112312' que vai ser o responsavel por assinar e verificar a autencidade do token jwt

8.Depois nos criamos o auth.js na pasta api onde terá o signin que servirá para autenticar o usuario, verificando sua senha e gerando seu jwt com o authSecret

Nos mais detalhadamente fariamos algo como:
-importamos o authSecret que criamos,importamos o jwt e bcrypt(bcrypt pra checar se o hash da nossa senha bate com a senha enviada pelo usuario)

-nos exportariamos uma função que receberia nossa instancia express(que tem ja a propriedade do knex configurada) e nos fariamos o nosso controller signin que vai receber email e password,checa primeiro se veio email e password na requisição,depois nos fazemos uma busca na tabela users se há um user com o email dado, se tiver nos vamos usar o bcrypt pra comparar a senha enviada pelo usuario com a hash do banco de dados(pegamos a instancia,a tupla,quando checamos se há o email passado pelo usuario) se nao der erro nos criamos uma payload que vai ser usada para criar o token,nessa payload tera id que vai receber o id do usuario, e como resposta nos mandamos o nome,email e token gerado(com a payload e authSecret) e exportamos esse controller no return.

9.Depois colocamos esse signin em routes.js para executar esse controller quando haver um post na rota /signin 

10.Depois nos criamos o middleware passport.js que vai ser usado para autenticar o jwt atraves do authSecret,que a ideia geral é que o passport faz o uso de uma estrategia de validação do token

mais detalhadamente:
-nos importamos o authSecret q criamos no .env

-importamos o passport que pode receber vários tipos de "validador"

-o nosso "validador" vai ser o passportJwt q tbm importamos

-desse passportJwt nos camos desestruturar ele pegando  o objeto Strategy e o ExtractJwt

-nos vamos criar dentro da função que recebe a instancia do express um objeto params que vai ter secretkey que nos criamos no .env, o jwtFromRequest que indica que extrairemos o jwt no header da requisição

-teremos uma strategy que nos vamos usar o Objeto Strategy que vai receber os params que criamos, e uma callback recebendo payload e done, essa payload seria a payload que criamos quando criamos o token me que fazemos uma payload que tem um id dentro, entao nos pegariamos o id oriundo desse jwt e verificariamos se ele existe no db, se existir é validado

-e usamos essa strategy no passport

-por ultimo temos coisas sendo retornadas, o initialize é usada para inicializar o Passport na aplicação Express(fazemos isso no index.js na parte do include).
authenticate é usada para validar as requisições com o JWT, garantindo que o token seja válido antes de permitir o acesso a rotas protegidas,isso nos usamos como middleware mesmo antes dos controllers.

-No fim vi que nos basicamente pegamos a authsecret e o id vindo do jwt pra validar o token que foi gerado


11.E por fim do projeto da api nos fazemos o arquivo task.js e a migration de tasks, onde vai ter os controllers no task.js pra parte de requisições get,post etc